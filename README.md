# Оглавление
- [Основные положения](#основные-положения)
  - [Типы данных](#типы-данных)
  - [Регистрозависимость](#регистрозависимость)
  - [Служебные слова](#служебные-слова)
- [Работа с ITMOVA](#основные-положения)

**ITMOVA** - это Forth-подобный язык программирования для STM32.

Разработан студентами Университета ИТМО:
- Перевозчиков Иван
- Антонов Всеволод
- Неграш Андрей

**Версия:** *1.0*

**Последнее обновление:** *20.05.2023*

# Основные положения
## Типы данных
В ITMOVA реализовано 5 типов данных и 1 тип возвращаемого значения `void`: 

| Название    | Описание                 | Микрокоманда | По умолчанию         | Диапазон данных          |
|-------------|--------------------------|--------------|----------------------|--------------------------|
| **bool**    | логический               | BLN (200)    | FALSE                | TRUE *или* FALSE         |
| **int**     | целочисленный            | INT (201)    | 0                    | $-2^{31}$ ... $2^{31}$   |
| **float**   | число с плавающей точкой | FLT (202)    | 0.0                  | $-10^{45}$ ... $10^{38}$ |
| **string**  | строковый                | STR (203)    | "" *(пустая строка)* | a-Z, 0-9, *пробел*       |
| **pointer** | указатель                | PTR (204)    | -                    | -                        |
| **void**    | метод                    | VOID (205)   | -                    | -                        |

Стоит заметить, что типы `float` и `int` являются несовместимыми (преобразовать один в другой нельзя).

Все типы данных указываются при помощи символа `:` и пишутся в нижнем регистре.

## Регистрозависимость
Язык ITMOVA относится к регистрозависимым языкам программирования.

В `ВЕРХНЕМ` регистре пишутся имена переменных, параметров и некоторые служебные слова.

В `нижнем` регистре пишутся наименования типов данных и имена функций.

## Служебные слова
В данном разделе представлены зарезервированные языком программирования слова, которые нельзя использовать для наименования переменных.

Все служебные слова всегда пишутся в верхнем регистре.

- `MAKE_YOURSELF_GREAT_AGAIN` - начало программы на языке ITMOVA
- `START` - начало блока кода внутри цикла, функции или условного оператора
- `FINISH` - конец блока кода внутри цикла, функции или условного оператора
- `RETURN` - обозначение возвращаемого значения
- `FROM` - обозначение нижней границы цикла from
- `TO` - обозначение верхней границы цикла from
- `WITH` - обозначение шага в цикле from
- `IF` - обозначение условия

# Работа с ITMOVA
## Объявление переменных 
В ITMOVA существует возможность объявлять переменные определённого типа, присваивать им значения и менять его в процессе выполнения программы.

При объявлении переменной ей автоматически присваивается значение по умолчанию (в зависимости от типа). 
Присвоить своё значение во время инициализации переменной нельзя - для этого нужно дополнительно использовать команду assign().

Объявление переменных осуществляется по следующему шаблону: 
```
VAR_NAME_IN_UPPERCASE : TYPE;
```
### Список параметров
- `VAR_NAME_IN_UPPERCASE` - имя переменной строго в верхнем регистре
- `TYPE` - тип переменной

### Пример
```
VARIABLE : float;
```
    
## Объявление функций 
Для написания качественного и читаемого кода в ITMOVA реализована возможность пользоваться не только встроенными в ITMOVA core функциями, но и создавать свои с произвольным функционалом. 

Обратите внимание, что функциям нельзя давать названия, совпадающие с уже существующими в рамках ITMOVA core. 
Также стоит помнить, что все функции должны быть объявлены до точки входа в листинг основной программы, иначе работа с ними будет недоступна.
В завершающей строке кода функции обязательно должен быть RETURN с возвращаемым значением.

Объявление функций осуществляется по следующему шаблону:
```
func_name_in_lowercase (PARAM_NAME_IN_UPPERCASE : TYPE, ...) : FUNC_TYPE
    START
        <code>
    FINISH
```
### Список параметров
- `func_name_in_lowercase` - имя функции в нижнем регистре
- `PARAM_NAME_IN_UPPERCASE` - имя параметра в верхнем регистре
- `TYPE` - тип переменной
- `FUNC_TYPE` - тип возвращаемого функцией значения
- `START`- служебное слово
- `FINISH` - служебное слово
- `RETURN` - служебное слово

### Пример
```
my_sum (A: float, B: float) : float
    START
        RES : float;
        assign(RES, sum(A, B));
        RETURN RES;
    FINISH
```

## Вызов функций 
Чтобы вызвать любую функцию (свою или из ITMOVA core) требуется после точки входа в основной листинг программы прописать с маленькой буквы имя нужной функции.

Обращаем внимание, что функции могут вкладываться друг в друга и, соответственно, использовать возвращаемое значение в качестве своих аргументов.

Вызов функции осуществляется по следующему шаблону:
```
func_name_in_lowercase (PARAM_NAME_IN_UPPERCASE, ...);
```
### Список параметров
- `func_name_in_lowercase` - имя функции в нижнем регистре
- `PARAM_NAME_IN_UPPERCASE` - имя передаваемого параметра в верхнем регистре или передаваемое значение заданного типа

### Примеры
```
print(VARIABLE);

print("this is string");
```

## Цикл from
Цикл from в ITMOVA является упрощённой формой итеративного цикла for, известного по другим языкам программирования.

Обратите внимание, что при передаче в качестве LOWER_BORDER переменной, её значение не будет меняться, так что для счётчика потребуется создать отдельную переменную и увеличивать (или уменьшать) её на необходимое значение

Объявление цикла from осуществляется по следующему шаблону:
```
FROM LOWER_BORDER TO UPPER_BORDER WITH STEP:
    START
        <code>
    FINISH
```
### Список параметров
- `FROM`- служебное слово
- `TO` - служебное слово
- `WITH` - служебное слово
- `LOWER_BORDER` - начальное значение для цикла типа int
- `UPPER_BORDER` - конечное значение для цикла типа int
- `STEP` - шаг увеличения типа int
- `START`- служебное слово
- `FINISH` - служебное слово

### Пример
```
FROM 1 TO 5 WITH 1:
    START
        print("Hello");
    FINISH
```
    
## Условный оператор if 
В ITMOVA реализована возможность работы с условным оператором

Обращаем внимание, что отсутствует привычный блок ELSE. Для реализации данной логики рекомендум использовать повторный IF с таким же параметром, заключённым в функцию not().

Объявление условного оператора осуществляется по следующему шаблону:
```
IF bool_var:
    START
        <code>
    FINISH
```
### Список параметров
- `IF` - служебное слово
- `bool_var` - имя переменной логического типа в верхнем регистре или функция, возвращающая логическое значение
- `START`- служебное слово
- `FINISH` - служебное слово

### Пример
```    
IF less(FIRST, SECOND):
    START
        SECOND = SECOND - FIRST;
    FINISH
```

# Как работает ITMOVA
Работа языка ITMOVA осуществляется по следующим шагам:
1. Написание текста программы на лексике ITMOVA
2. Компиляция текста в байт-код средствами компилятора, реализованного на Java
3. Передача байт-кода интерпретатору, находящемуся на STM32 (написан на C)
4. Выполнение байт-кода на STM32 и получение результатов

## Стеки в ITMOVA
В ITMOVA реализовано 2 стека: стек данных и стек возврата.

## Байт-код
Байт-код представляет собой микрооперацию и её код в виде числа в десятичном виде

### Системные микрокоманды 
Выделенный диапазон: [0-99]

| Микрокоманда | Код | Описание                                                                                                                                                                               |
|--------------|-----|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **exit**     | 0   | точка завершения основной программы                                                                                                                                                    |
| **jmp**      | 1   | переход по абсолютному адресу (переходит по адресу, который лежит в следующей микрокоманде)                                                                                            |
| **jdec**     | 2   | переход с автоматическим декрементом (cмотрит значение по адресу, который лежит в следующей микрокоманде, и если это значение при декременте не равно нулю, переходит по этому адресу) |
| **jret**     | 3   | переход по адресу на вершине стека (получает значение с вершины стека возврата и переходит по этому адресу)                                                                            |
| **loop**     | 10  | начало цикла from                                                                                                                                                                      |
| **jt**       | 20  | переход, если на вершине стека не нулевое значение                                                                                                                                     |

### Микрооперации для работы с функциями 
Выделенный диапазон: [100-199]

| Микрокоманда | Код | Описание                                                              |
|--------------|-----|-----------------------------------------------------------------------|
| **call**     | 100 | вызов функции, следующей командой будет адрес данной функции в памяти |
| **lit**      | 110 | вид передачи аргумента - литерал                                      |
| **var**      | 111 | вид передачи аргумента - переменная                                   |
| **ofc**      | 112 | вид передачи аргумента - вызов другой функции                         |
| **rlit**     | 120 | вид возвращаемого аргумента - литерал                                 |
| **rvar**     | 121 | вид возвращаемого аргумента - переменная                              |
| **rofc**     | 122 | вид возвращаемого аргумента - вызов другой функции                    |

### Микрооперации типов переменных и функций 
Выделенный диапазон: [200-299]

| Микрокоманда | Код | Описание                                          |
|--------------|-----|---------------------------------------------------|
| **BLN**      | 200 | обозначение логического типа (bool)               |
| **INT**      | 201 | обозначение целочисленного типа (int)             |
| **FLT**      | 202 | обозначение типа чисел с плавающей точкой (float) |
| **STR**      | 203 | обозначение строкового типа (string)              |
| **PTR**      | 204 | обозначение указателей (pointer)                  |
| **VOID**     | 205 | обозначение метода                                |

### ITMOVA core 
Выделенный диапазон: [700-799]

| Микрокоманда | Код | Описание                                                                                  |
|--------------|-----|-------------------------------------------------------------------------------------------|
| **print**    | 700 | вывод данных на экран                                                                     |
| **assign**   | 701 | присвоение значения переменной                                                            |
| **get_data** | 710 | возвращает значение, которые лежит по указателю                                           |
| **set_data** | 711 | записывает значение по указателю                                                          |
| **get_addr** | 712 | возвращает адрес переменной                                                               |
| **malloc**   | 713 | присваивает указателю, передаваемому как аргумент функции, первый свободный адрес из кучи |
| **and**      | 720 | возвращает значение логического И                                                         |
| **or**       | 721 | возвращает значение логического ИЛИ                                                       |
| **not**      | 722 | возвращает значение логического НЕ                                                        |
| **concat**   | 725 | возвращает строку, полученную с помощью конкатенации двух переданных                      |
| **substr**   | 726 | возвращает подстроку из исходной, заданной длины и с определённого символа                |
| **like**     | 727 | возвращает логическое значение вхождение одной строки в другую                            |
| **length**   | 728 | возвращает длину строки                                                                   |
| **abs**      | 735 | возвращает значение числа по модулю                                                       |
| **sin**      | 736 | возвращает синус числа                                                                    |
| **cos**      | 737 | возвращает косинус числа                                                                  |
| **inc**      | 738 | возвращает увеличенное на 1 число                                                         |
| **dec**      | 739 | возвращает уменьшенное на 1 число                                                         |
| **log**      | 755 | возвращает значение логарифма                                                             |
| **pow**      | 756 | возвращает значение возведённого в степень числа                                          |
| **sum**      | 757 | возвращает значение суммы аргументов                                                      |
| **sub**      | 758 | возвращает значение вычитания аргументов                                                  |
| **mul**      | 759 | возвращает значение произведения аргументов                                               |
| **div**      | 760 | возвращает значение деления аргументов                                                    |
| **mod**      | 761 | возвращает значение остатка деления аргументов                                            |
| **min**      | 762 | возвращает значение минимального из аргументов                                            |
| **max**      | 763 | возвращает значение максимального из аргументов                                           |
| **less**     | 764 | возвращает логическое значение сравнения аргументов                                       |
| **greater**  | 765 | возвращает логическое значение сравнения аргументов                                       |
| **equal**    | 766 | возвращает логическое значение сравнения аргументов                                       |
| **PI**       | 775 | возвращает значение числа пи                                                              |
| **E**        | 776 | возвращает значение числа Эйлера                                                          |
| **random**   | 777 | возвращает случайное число с плавающей точкой                                             |

# ITMOVA core
Подробнее о стандартной библиотеке языка ITMOVA. В рамках данной библиотеки были реализованы самые необходимые базовые функции для проведения вычислений. Любые не представленные здесь функции можно получить с помощью арифметических операций: например, тангенс можно получить путём деления синуса на косинус.

## Системные функции
В данном разделе представлены функции общего назначения для работы с системой. 

#### print()
Функция выводит результат на экран

`print(A: any) : void`

**Список параметров:**
- `A` - значение одного из типов, предназначенное для вывода пользователю

#### assign()
Присвоение значения переменной

`assign(A: any, VALUE: any) : void`

**Список параметров:**
- `A` - переменная, которой будет присвоено значение
- `VALUE` - присваиваемое значение заданного типа переменной

## Функции для работы с динамической памятью
В данном разделе представлены функции, которые работают с указателями и динамической памятью.

#### get_data()
Возвращает значение, которе находится по переданному в аргументы указателю

`get_data(P: pointer) : any`

**Список параметров:**
- `P` - указатель на ячейку памяти

#### set_data()
Записывает значение из второго аргумента по переданному в первом аргументе указателю. Функция возвращает true, если запись прошла успешно, и false, если возник, например, конфликт типов данных

`set_data(P: pointer, VALUE: any) : bool`

**Список параметров:**
- `P` - указатель на ячейку памяти
- `VALUE` - записываемое значение

#### get_addr()
Возвращает адрес переменной в памяти

`get_addr(A: any) : pointer`

**Список параметров:**
- `A` - переменная, адрес которой будет возвращён

#### malloc()
Присваивает указателю, который передается как аргумент функции, первый свободный адрес из кучи. При выполнении этой операции адресу в куче не присваивается определённый тип. При первой записи по этому адресу возможна передача данных любого типа, после чего ему назначается тип этого значения. В дальнейшем запись данных других типов приведет к ошибке выполнения программы.

`malloc(P: pointer) : void`

**Список параметров:**
- `P` - присваивает этому адресу первый свободный адрес из кучи

## Функции для типов
В данном разделе представлены функции, которые являются основными для того или иного типа данных.

### Bool
Логический тип данных. 

#### and()
Функция возвращает значение логического И от двух аргументов

`and(A: bool, B: bool) : bool`

**Список параметров:**
- `A` - первое логическое значение
- `B` - второе логическое значение

#### or()
Функция возвращает значение логического ИЛИ от двух аргументов

`or(A: bool, B: bool) : bool`

**Список параметров:**
- `A` - первое логическое значение
- `B` - второе логическое значение

#### not()
Функция возвращает значение логического НЕ от одного аргумента

`not(A: bool) : bool`

**Список параметров:**
- `A` - логическое значение

### String
Строковый тип данных. 

#### concat()
Функция возвращает одну строку, полученную путём склеивания двух переданных строк в качестве аргументов

`concat(A: string, B: string) : string`

**Список параметров:**
- `A` - первая часть строки
- `B` - вторая часть строки

#### substr()
Функция возвращает подстроку заданной длины, начиная с заданной позиции первого символа

`substr(A: string, B: int, C: int) : string`

**Список параметров:**
- `A` - исходная строка
- `B` - стартовая позиция искомой подстроки
- `C` - длина искомой подстроки

#### like()
Функция ищет вхождения подстроки в исходную строку и возвращает логическое значение, если вхождение найдено

`like(A: string, B: string) : bool`

**Список параметров:**
- `A` - исходная строка
- `B` - искомая подстрока

#### length()
Функция возвращает длину переданной строки

`length(A: string) : int`

**Список параметров:**
- `A` - исходная строка

## Библиотека Math
В данной библиотеке представлены более сложные математические операции, которые позволят производить сложные вычисления и писать более полезные программы.

### Унарные операции
В данном подразделе представлены операции, производимые над одним операндом и возвращающие один результат

#### abs()
Функция возвращает значение по модулю от переданного числа

`abs(A: float) : float`

**Список параметров:**
- `A` - число, которое будет взято по модулю

#### sin()
Функция возвращает значение синуса для переданного числа

`sin(A: float) : float`

**Список параметров:**
- `A` - число, синус которого будет вычислен

#### cos()
Функция возвращает значение косинуса для переданного числа

`cos(A: float) : float`

**Список параметров:**
- `A` - число, косинус которого будет вычислен

#### inc()
Функция инкрементирует переданное число и возвращает результат

`inc(A: float) : float`

**Список параметров:**
- `A` - число, которое будет увеличено на 1

#### dec()
Функция декрементирует переданное число и возвращает результат

`dec(A: float) : float`

**Список параметров:**
- `A` - число, которое будет уменьшено на 1

### Бинарные операции
В данном подразделе представлены операции, принимающие на вход 2 аргумента и выдающие 1 результат.

#### log()
Функция возвращает значение логарифма второго аргумента по основанию, переданному первым аргументом

`log(A: float, B: float) : float`

**Список параметров:**
- `A` - основание вычисляемого логарифма
- `B` - число, для которого будет вычисляться логарифм

#### pow()
Функция возводит передаваемое число в передаваемую степень и возвращает результат

`pow(A: float, B: float) : float`

**Список параметров:**
- `A` - основание степени
- `B` - показатель степени

#### sum()
Функция складывает 2 числа и возвращает результат

`sum(A: float, B: float) : float`

**Список параметров:**
- `A` - первое слагаемое
- `B` - второе слагаемое

#### sub()
Функция вычитает из одного числа другое и возвращает результат

`sub(A: float, B: float) : float`

**Список параметров:**
- `A` - уменьшаемое
- `B` - вычитаемое

#### mul()
Функция перемножает 2 числа и возвращает результат

`mul(A: float, B: float) : float`

**Список параметров:**
- `A` - первый множитель
- `B` - второй множитель

#### div()
Функция делит одно число на другое и возвращает результат

`div(A: float, B: float) : float`

**Список параметров:**
- `A` - делимое
- `B` - делитель

#### mod()
Функция делит одно число на другое и возвращает остаток от деления

`mod(A: float, B: float) : int`

**Список параметров:**
- `A` - делимое
- `B` - делитель

#### min()
Функция возвращает меньшее из двух переданных чисел

`min(A: float, B: float) : float`

**Список параметров:**
- `A` - первое сравниваемое число
- `B` - второе сравниваемое число

#### max()
Функция возвращает большее из двух переданных чисел

`max(A: float, B: float) : float`

**Список параметров:**
- `A` - первое сравниваемое число
- `B` - второе сравниваемое число

#### less()
Функция возвращает TRUE, если первый операнд меньше второго, иначе FALSE

`less(A: float, B: float) : bool`

**Список параметров:**
- `A` - первое сравниваемое число
- `B` - второе сравниваемое число

#### greater()
Функция возвращает TRUE, если первый операнд больше второго, иначе FALSE

`greater(A: float, B: float) : bool`

**Список параметров:**
- `A` - первое сравниваемое число
- `B` - второе сравниваемое число

#### equal()
Сравнивает два операнда по значению

`equal(A: any, B: any) : bool`

**Список параметров:**
- `A` - первый сравниваемый операнд
- `B` - второй сравниваемый операнд

### Без аргументов
В данном подразделе представлены некоторые константы и функция для формирования случайных чисел. Все они работают без аргументов.

#### PI()
Функция возвращает значение числа π с точностью 13 знаков после запятой

`PI() : float`

#### E()
Функция возвращает значение числа Эйлера с точностью 13 знаков после запятой

`E() : float`


#### random()
Функция возвращает случайное значение в диапазоне [0; 1]

`random() : float`

# Примеры программ
В данном разделе приведены примеры простейших работающих программ на языке ITMOVA.

## Первая программа
Классическая программа для того, чтобы начать.
```
print("Hello, world!");
```

Вывод программы:
```
Hello, world!
```

## Работа с переменными
Попробуем инициализировать переменные всех типов и посмотреть на их значения по умолчанию.
```
BOOL_VAR : bool;
STRING_VAR : string;
INT_VAR : int;
FLOAT_VAR : float;

print(BOOL_VAR);
print(STRING_VAR);
print(INT_VAR);
print(FLOAT_VAR);
```

Вывод программы:
```
FALSE

0
0.0
```

## Функция в функции
```
my_func(A: float, B:string):void
    START
    my_func2(A:float, B:string):int
        START
        print(A);
        printf(sum(A, length(B)));
    FINISH
    print(sum(A, length(B)));
FINISH
```

## Работа условного оператора
В данной программе демонстрируется работа условного оператора, цикла в нём и работа функции
```
my_func (A: float, B: float): float // - (A + B)
    START
        C: float; // C = 0
        assign(C, sub(C, A)); // C = C - A
        assign(C, sub(C, B)); // C = C - B
        RETURN C;
    FINISH

A: float;
B: float;

assign(A, 12);
assign(B, 13);

IF less(A, B):
    START
	I : int;
	inc(I);
        FROM I TO 10 WITH 1:
	    START
                print(I);
                inc(I);
	    FINISH
        print(my_func(A, B));
    FINISH
```
